#!/usr/bin/with-contenv bashio
set -euo pipefail

log() { echo "$(date -Iseconds) [streamer] $*"; }

STREAM_KEY=$(bashio::config 'stream_key')
PRINTER_URL=$(bashio::config 'printer_url')
CHECK_INTERVAL=$(bashio::config 'check_interval')
STATUS_URL="$(echo "${PRINTER_URL}" | sed -E 's#^(https?://[^/]+).*#\1#')"

RTMP_BASE="rtmp://rtmp.deployor.dev:1935/live/"
RTMP_PUBLISH_URL="${RTMP_BASE}${STREAM_KEY}"

FFMPEG_PID=""

is_ffmpeg_running() {
  [[ -n "${FFMPEG_PID:-}" ]] && kill -0 "${FFMPEG_PID}" 2>/dev/null
}

start_stream() {
  log "Starting FFmpeg: ${PRINTER_URL} -> ${RTMP_PUBLISH_URL}"
  ffmpeg -f mjpeg -i "${PRINTER_URL}" -c:v libx264 -vf format=yuv420p -b:v 2500k -bufsize 5000k -maxrate 2500k -g 30 -preset ultrafast -tune zerolatency -flags +global_header -f flv "${RTMP_PUBLISH_URL}" &
  FFMPEG_PID=$!
  log "FFmpeg started with PID ${FFMPEG_PID}"
}

stop_stream() {
  if is_ffmpeg_running; then
    log "Stopping ffmpeg PID ${FFMPEG_PID}"
    kill "${FFMPEG_PID}" 2>/dev/null || true
    wait "${FFMPEG_PID}" 2>/dev/null || true
  fi
  FFMPEG_PID=""
}

check_online() {
  # Consider online if a quick GET returns HTTP 200 on the base URL (host:port)
  curl -s --fail -o /dev/null --max-time 5 "${STATUS_URL}"
}

cleanup() {
  log "Termination signal received, cleaning up..."
  stop_stream
  exit 0
}

trap cleanup SIGTERM SIGINT

log "Starting monitor loop (interval: ${CHECK_INTERVAL}s)"

while true; do
  if check_online; then
    if ! is_ffmpeg_running; then
      start_stream || { log "Error: failed to start ffmpeg"; FFMPEG_PID=""; }
    fi
  else
    if is_ffmpeg_running; then
      log "Printer offline, stopping stream"
      stop_stream
    else
      log "Printer offline, waiting"
    fi
  fi

  # ffmpeg died unexpectedly -> reset state; will restart next tick if online
  if [[ -n "${FFMPEG_PID:-}" ]] && ! is_ffmpeg_running; then
    log "ffmpeg exited unexpectedly"
    FFMPEG_PID=""
  fi

  sleep "${CHECK_INTERVAL:-10}"

done